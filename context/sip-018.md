# SIP-018: Signed Structured Data

**Status**: Ratified
**Author**: Marvin Janssen
**License**: CC0-1.0
**SIP**: https://github.com/stacksgov/sips/blob/main/sips/sip-018/sip-018-signed-structured-data.md

## Overview

SIP-018 defines a standard for deterministically encoding and signing structured data on Stacks. Unlike SIWS (which is for authentication), SIP-018 is for signing arbitrary Clarity data that can be verified both off-chain and on-chain by smart contracts.

## Use Cases

- **Proving address control**: Sign a message to prove you own an address
- **Meta-transactions**: Authorize actions to be executed by another party
- **Off-chain voting**: Sign votes that are tallied on-chain
- **Permit patterns**: Approve token transfers without on-chain transaction
- **Multi-sig coordination**: Collect signatures before on-chain execution

## Message Hash Construction

```
messageHash = sha256(structuredDataPrefix || domainHash || structuredDataHash)
```

Where:
- `structuredDataPrefix` = `0x534950303138` (ASCII "SIP018")
- `domainHash` = hash of domain tuple
- `structuredDataHash` = hash of the structured data being signed

## Domain Structure

The domain is a Clarity tuple that makes signatures chain and application specific:

```clarity
{
  name: "My Application",      ;; Application identifier
  version: "1.0.0",            ;; App version (invalidates old signatures)
  chain-id: u1                 ;; SIP-005 chain ID
}
```

**Purpose of each field:**
- `name`: Identifies the application
- `version`: Allows invalidating previous signatures on app updates
- `chain-id`: Prevents cross-chain replay attacks

## Structured Data

Any valid Clarity value can be signed. Typically a tuple with descriptive field names:

```clarity
;; Example: Token transfer authorization
{
  action: "transfer",
  token: 'SP123.my-token,
  amount: u1000000,
  recipient: 'SP456...,
  deadline: u100000
}
```

The data is encoded using SIP-005 wire format before hashing.

## Signing Process (TypeScript)

```typescript
import {
  hashStructuredData,
  signStructuredData
} from "@stacks/transactions";

// Define domain
const domain = tupleCV({
  name: stringAsciiCV("My App"),
  version: stringAsciiCV("1.0.0"),
  "chain-id": uintCV(1),
});

// Define structured data
const message = tupleCV({
  action: stringAsciiCV("approve"),
  amount: uintCV(1000000),
  spender: principalCV("SP123..."),
});

// Sign
const signature = signStructuredData({
  domain,
  message,
  privateKey,
});
```

## Verification (Clarity)

On-chain verification is simple and gas-efficient:

```clarity
(define-constant structured-data-prefix 0x534950303138)

(define-read-only (verify-sip018-signature
    (structured-data-hash (buff 32))
    (signature (buff 65))
    (signer principal))
  (let (
    (message-hash (sha256 (concat structured-data-prefix structured-data-hash)))
  )
    (is-eq
      (principal-of? (unwrap! (secp256k1-recover? message-hash signature) false))
      (ok signer)
    )
  )
)

;; Usage with domain
(define-constant domain-hash 0x2538b5dc06c5ae2f11549261d7ae174d9f77a55a92b00f330884695497be5065)

(define-read-only (verify-with-domain
    (structured-data-hash (buff 32))
    (signature (buff 65))
    (signer principal))
  (let (
    (full-hash (sha256 (concat structured-data-prefix (concat domain-hash structured-data-hash))))
  )
    (is-eq
      (principal-of? (unwrap! (secp256k1-recover? full-hash signature) false))
      (ok signer)
    )
  )
)
```

## Signature Format

- Algorithm: ECDSA with secp256k1
- Encoding: RSV order (65 bytes total)
  - R: 32 bytes
  - S: 32 bytes
  - V: 1 byte (recovery id)

## Security Considerations

### Collision Prevention

The `0x534950303138` prefix ensures SIP-018 messages cannot collide with:
- Stacks transactions (start with `0x00` or `0x80`)
- Clarity wire format values (start with `0x00`-`0x0C`)

### Replay Protection

- **Cross-chain**: `chain-id` in domain prevents replay on other chains
- **Cross-app**: `name` in domain prevents replay in other apps
- **Cross-version**: `version` in domain allows invalidating old signatures
- **Temporal**: Application-level (add deadline/nonce to structured data)

### Message Transparency

Unlike raw message signing, structured data is human-readable. Wallets can display the tuple fields meaningfully before requesting signature.

## Test Vectors

**Domain** (name: "Test App", version: "1.0.0", chain-id: 1):
```
Hash: 0x2538b5dc06c5ae2f11549261d7ae174d9f77a55a92b00f330884695497be5065
```

**Message** ("Hello World" string):
```
Hash: 0x1bfdab6d4158313ce34073fbb8d6b0fc32c154d439def12247a0f44bb2225259
```

**Full Message Hash**:
```
sha256(0x534950303138 || domainHash || messageHash)
```

## Comparison with SIWS

| Aspect | SIP-018 | SIWS (SIP-SIWS) |
|--------|---------|-----------------|
| Purpose | Sign arbitrary structured data | User authentication |
| Data format | Clarity tuples (binary) | Human-readable text |
| On-chain verification | Yes (efficient) | No (off-chain only) |
| Domain binding | Clarity tuple | Text field |
| Use case | Meta-tx, voting, permits | Web app login |

## When to Use SIP-018 vs SIWS

**Use SIP-018 when:**
- Data will be verified by a smart contract
- You need structured, typed data
- Building meta-transactions or permit patterns
- Off-chain voting with on-chain tallying

**Use SIWS when:**
- Authenticating users to a web application
- You only need off-chain verification
- Human readability is important
- Following web3 login standards

## Library Support

SIP-018 is supported in `@stacks/transactions`:

```typescript
import {
  signStructuredData,
  hashStructuredData,
  verifyStructuredDataSignature,
} from "@stacks/transactions";
```

## Example: Permit Pattern

```clarity
;; Contract storage
(define-map permits
  { owner: principal, spender: principal, token: principal }
  { amount: uint, deadline: uint, used: bool })

;; Verify permit signature and execute
(define-public (use-permit
    (owner principal)
    (spender principal)
    (amount uint)
    (deadline uint)
    (signature (buff 65)))
  (let (
    (permit-data (tuple
      (action "permit")
      (owner owner)
      (spender spender)
      (amount amount)
      (deadline deadline)))
    (data-hash (hash-structured-data permit-data))
  )
    ;; Verify deadline
    (asserts! (< stacks-block-height deadline) (err u1))
    ;; Verify signature
    (asserts! (verify-sip018-signature data-hash signature owner) (err u2))
    ;; Execute permitted action
    (try! (as-contract (contract-call? .token transfer amount owner spender none)))
    (ok true)
  )
)
```
